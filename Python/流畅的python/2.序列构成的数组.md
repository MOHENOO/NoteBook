# 内置序列类型

python 标准库用 C 实现了丰富的序列类型

- 容器类型
  list,tuple 和 collections.deque 等这些序列能存在不同类型的数据.
- 扁平序列
  str, bytes,bytearray,memoryview 和 array.array,这类序列只能容纳一种类型.

容器类型存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。
换言之，扁平序列其实是一段连续的内存空间。由此看见扁平序列其实更加紧凑，但它里面只能
存放诸如字符，字节和数值这种基础类型。

序列类型还能按照能否被修改来分类。

- 可变序列
  list,bytearray,array.array,collections.deque 和 memoryview.
- 不可变序列
  tuple,str 和 bytes.

## 列表推导和生成表达式

列表推导是构建列表的快捷方式,而生成器表达式则可以用来构建其他任何类型的序列。

通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。

python 会忽略代码里[],{}和()的换行。因此代码里面可以省略续行符\.

**python 2.x 中，在列表推导中 for 关键词之后的赋值操作可能会影响列表推导上下文中的同名变量。**

```python
x='1'
d= [x for x in 'ABC']
print(x)
# x = 'C'
```

上述情况在 python3 中不会出现。在 python3 中列表推导，生成器表达式以及同它们相似的集合推导和字典推导，
在 python3 中都有了自己的局部作用域，就像函数似的.表达式内部的变量和赋值只在局部起作用，表达式的上下文
里的同名变量还可以被正常引用，局部变量并不会影响到它们。

### 列表推导同 filter 和 map 的比较

filter 和 map 合起来能做的事情，列表推导也可以做，而且还不需要借助难以理解和阅读的 lambda 表达式.

```python
symbols = '$@#$%'
beyond_ascii = [ord(s) for s in symbols if ord(s)>127]
print(beyond_ascii)

beyond_ascii = list(filter(lambda c:c > 127, map(ord,symbols)))
```

### 笛卡儿积

```python
colors = ['black','white']
sizes = ['S','M','L']
tshirts = [(color,size) for color in colors
           for size in sizes]
```

### 生成器表达式

虽然也可以用列表推导来初始化元组，数组或其他序列类型，但是生成器表达式是更好的选择。
这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产生元素，而不是先建立一个完整列表，
然后再把这个列表传递到某个构造函数里。显然前面那种方式可以节省内存。

```python
symbols = '$@#$%'
tuple(ord(symbol) for symbol in symbols)
import array
array.array('I',(ord(symbol) for symbol in symbols))
```

## 元组不仅仅是不可变的列表

元组除了是不可变列表外，还可以用于没有字段名的记录。

### 元组和记录

元组其实是对数据的记录，元组中的每个元组都存放了记录中一个字段的数据，外加这个字段的位置。
正是这个位置信息给数据赋予了意义。
如果只把元组理解为不可变的列表，那其他信息----它所含有的元组的总数和它们的位置
似乎就变得可有可无。但是如果把元组当作一些字段的集合，那么数量和位置信息就
变得非常重要。

```python
lax_coordinates = (33.9425,-118.408056)
city,year,pop,chg,area = ('Tokey',2003,32450,0.66,8014)
traveler_ids = [('USA','31195855'),('BRA','CE342567'),('ESP','XDA205856')]
for passport in  sorted(traveler_ids):
    print('%s/%s'%passport)

for country,_ in traveler_ids:
    print(country)
```

拆包让元组可以完美地当作记录来使用。

### 元组拆包

元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟
接受这些元素的元组的空档数一致。除非我们用\*来忽略多于的元素。
最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到有对应变量
组成的元组中。
