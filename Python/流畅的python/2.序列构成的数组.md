# 内置序列类型

python 标准库用 C 实现了丰富的序列类型

- 容器类型
  list,tuple 和 collections.deque 等这些序列能存在不同类型的数据.
- 扁平序列
  str, bytes,bytearray,memoryview 和 array.array,这类序列只能容纳一种类型.

容器类型存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。
换言之，扁平序列其实是一段连续的内存空间。由此看见扁平序列其实更加紧凑，但它里面只能
存放诸如字符，字节和数值这种基础类型。

序列类型还能按照能否被修改来分类。

- 可变序列
  list,bytearray,array.array,collections.deque 和 memoryview.
- 不可变序列
  tuple,str 和 bytes.

## 列表推导和生成表达式

列表推导是构建列表的快捷方式,而生成器表达式则可以用来构建其他任何类型的序列。

通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。

python 会忽略代码里[],{}和()的换行。因此代码里面可以省略续行符\.

**python 2.x 中，在列表推导中 for 关键词之后的赋值操作可能会影响列表推导上下文中的同名变量。**

```python
x='1'
d= [x for x in 'ABC']
print(x)
# x = 'C'
```

上述情况在 python3 中不会出现。在 python3 中列表推导，生成器表达式以及同它们相似的集合推导和字典推导，
在 python3 中都有了自己的局部作用域，就像函数似的.表达式内部的变量和赋值只在局部起作用，表达式的上下文
里的同名变量还可以被正常引用，局部变量并不会影响到它们。

### 列表推导同 filter 和 map 的比较

filter 和 map 合起来能做的事情，列表推导也可以做，而且还不需要借助难以理解和阅读的 lambda 表达式.

```python
symbols = '$@#$%'
beyond_ascii = [ord(s) for s in symbols if ord(s)>127]
print(beyond_ascii)

beyond_ascii = list(filter(lambda c:c > 127, map(ord,symbols)))
```

### 笛卡儿积

```python
colors = ['black','white']
sizes = ['S','M','L']
tshirts = [(color,size) for color in colors
           for size in sizes]
```

### 生成器表达式

虽然也可以用列表推导来初始化元组，数组或其他序列类型，但是生成器表达式是更好的选择。
这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产生元素，而不是先建立一个完整列表，
然后再把这个列表传递到某个构造函数里。显然前面那种方式可以节省内存。

```python
symbols = '$@#$%'
tuple(ord(symbol) for symbol in symbols)
import array
array.array('I',(ord(symbol) for symbol in symbols))
```

## 元组不仅仅是不可变的列表

元组除了是不可变列表外，还可以用于没有字段名的记录。

### 元组和记录

元组其实是对数据的记录，元组中的每个元组都存放了记录中一个字段的数据，外加这个字段的位置。
正是这个位置信息给数据赋予了意义。
如果只把元组理解为不可变的列表，那其他信息----它所含有的元组的总数和它们的位置
似乎就变得可有可无。但是如果把元组当作一些字段的集合，那么数量和位置信息就
变得非常重要。

```python
lax_coordinates = (33.9425,-118.408056)
city,year,pop,chg,area = ('Tokey',2003,32450,0.66,8014)
traveler_ids = [('USA','31195855'),('BRA','CE342567'),('ESP','XDA205856')]
for passport in  sorted(traveler_ids):
    print('%s/%s'%passport)

for country,_ in traveler_ids:
    print(country)
```

拆包让元组可以完美地当作记录来使用。

### 元组拆包

元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟
接受这些元素的元组的空档数一致。除非我们用\*来忽略多于的元素。
最好辨认的元组拆包形式就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到有对应变量
组成的元组中。

```python
lax_coordinates = (33.9425,-118.408056)
latitude, longitude = lax_coordinates
```

另外一个很优雅的写法当属不使用中间变量交换两个变量的值。

```python
a,b = b,a
```

还可以用\*运算符把一个可迭代对象拆开作为函数的参数

```python
divmod(20,8)
t=(20,8)
divmod(*t)
quotient, remainder = divmod(*t)
```

下面是另一个例子，这个元组拆包的用法则是让一个函数可以用元组的形式返回多个值，然后调用函数的
代码就能轻松地接受这些返回值。比如 os.path.split()函数就会返回以路径和最后一个文件名组成的元组(path,last_part)

```python

import os

_,filename = os.path.split('/home/luciano/.ssh/idrsa.pub')
```

在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣，\_占位符能帮忙处理这种情况。

**如果做的是国际化软件，那么\_可能就不是一个理想的占位符，因为它也是 gettext.gettext 函数的常用别名。**
除此之外，在元组拆包中使用*也可以帮助我们把注意力使用集中在元组的部分元素上。在 python 中，函数使用*args
来获取不确定数量的参数算是一种经典写法了。
于是 python3 里，这个概念被扩展到平行赋值中。(python2 不支持)

```python
a, b, *rest = range(5)
```

另外元组拆包还有强大的功能，那就是可以应用在嵌套结构中.

### 嵌套元组拆包

接受表达式的元组可以是嵌套的。例如(a,b,(c,d))。只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，
python 就可以作出正确的对应。

```python
metro_areas = [('Tokyo','JP',36.933,(35.689722,139.691667))]
print('{:15}|{:^9}|{:^9}'.format('','lat.','long.'))
fmt = '{:15}|{:9.4f}|{:9.4f}'
for name,cc,pop, (latitude, longitude) in metro_areas:
    if longitude>=0:
        print(fmt.format(name,latitude,longitude))
```

元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能:我们时常会需要给记录中的字段命令。
nametuple 函数的出现帮我们解决了这个问题。

### 具名元组

collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类--这个带名字的类对调试程序有很大的帮助。

用namedtuple构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来
也要小一些,因为python不会用__dict__ 来存放这些实例的属性.

```python
from collections import namedtuple
City = namedtuple('City','name country population coordinates')
tokey = City('Tokyo','JP',36.933,('35.689722,139.691667'))
```

创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字，后者可以是由数个字符串组成的可
迭代对象，或者是由空格分隔开的字段名组成的字符串。

存放在对应字段离得数据要以一串参数的形式传入到构造函数中(注意，元组的构造函数只接受单一的可迭代对象)

你可以通过字段名或者位置来获取一个字段的信息。

除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性。

```python
from collections import namedtuple
City = namedtuple('City','name country population coordinates')
tokey = City('Tokyo','JP',36.933,('35.689722,139.691667'))
# _fields 属性是一个包含这个类所有字段名称的元组
City._fields
LatLong = namedtuple('LatLong','latlong')
delhi_data =  ('DelhiNCR','IN',21.935,LatLong(28.613889,77.208889))
# _make()通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟
# City(*delhi_data)是一样的。
delhi = City._make(delhi_data)
# _asdict()把具名元组以collections.OrderedDict的形式返回，我们可以利用它
# 把元组里的信息友好的呈现出来
delhi._asdict()
```

现在我们知道了，元组是一种很强大的可以当作记录来用的数据类型。它的第二个角色则是
充当一个不可变的列表

### 作为不可变列表的元组

如果要把元组当作列表来用的话，最好先了解下他们的相似度如何。
除了跟增减元组相关的方法之外，元组支持列表的其他所有方法。还有一个例外，
元组没有__reversed__方法，但是这个方法只是个优化而已。

## 切片

在python里，像列表，元组和字符串这类序列类型都支持切片操作，但是实际上切片操作比人们所
想象的要强大的多.

### 为何切片和区间会忽略最后一个元素。

- 当只有最后一个位置信息的时候，我们也可以快速看出切片和区间里面有几个元素,range(3) 和my_list[:3]都返回3个元素.
- 当起止位置信息都可见时，我们可以快速计算出切片和区间的长度，用后一个数减去第一个下标即可。
- 这样做也让我们可以利用任意一个下标来吧序列分割成不重叠的两部分，只要写成my_list[:x]和my_list[x:]就可以作出正确的对应。

### 对对象进行切片

一个众所周知的秘密是，我们还可以用s[a:b:c]的形式对s在a和b之间以c为间隔取值。c的值还可以为负。

### 多维切片和省略

[]运算符里还可以使用逗号分开的多个索引或者切片，外部库numpy里就用到了这个特性,二维的numpy.ndarray就可以用
a[i,j]这种形式来获取，或者是用a[m:n,k:l]的方式获取二维切片。要正确处理这种[]运算符的话，对象的特殊方法__getitem__
和__setitem__需要以元素的形式来接受a[i,j]中的索引。也就是说,如果要得到a[i,j]的值，python会调用a.__getitem__((i,j))

python内置的序列类型都是一维的，因此它们只支持单一的索引,成对出现的索引是没有用的.

省略的正确书写方法是3个英文句号。省略在python解释器眼里是一个符号,而实际上它是Ellipsis对象的别名,而Ellipsis对象又是ellipsis类
的单一实例.它可以当作切片规范的一部分，也可以用在函数的参数列表中。比如f(a, ..., z)或a[i:...].在numpy中，...用作多维数组切片的快捷方式。
如果x是四维数组,那么x[i,...]就是x[i,:,:,:]缩写。

### 给切片赋值

如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接，切除或就地修改。

```python
l = list(range(10))
l[2:5]=[20,30]
del l[5:7]
l[3::2]=[11,22]
l[2:5]=[100]
```

- 如果赋值的对象是一个切片，纳闷赋值语句的右侧必须是一个可迭代对象，即便只有单独一个值，也要把它转换成可迭代的序列。

## 对序列使用+和*

python程序员会默认序列是支持+和*操作的。通常+号两侧的序列是相同类型的数据所构成，在拼接的过程中，两个
序列都不会被修改，python会新建一个包含同样类型数据的序列来作为拼接的结果。

如果想要把一个序列复制几分然后在拼接起来，更快捷的做法是把这个序列乘以一个整数。同样这个操作会产生一个新序列。

**如果是a*n这个语句中，序列a里的元素是对其他可变对象的引用的话，你就需要格外注意了,因为这个式子的结果可能会出乎意料，
比如,你想用my_list=[[]]*3来初始化一个由列表组成的列表,但是你得到的列表里面包含的三个元素其实是3个引用，而这三个
引用只想的都是一个列表.**

```python
board = [['_']*3 for i in range(3)]
# 错误示例
board =[['_']*3]*3 
```
