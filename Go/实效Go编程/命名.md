# 命名


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [命名](#命名)
	* [包名](#包名)
	* [获取器](#获取器)
	* [接口名](#接口名)
	* [驼峰记法](#驼峰记法)

<!-- /code_chunk_output -->

正如命名在其它语言中的地位，它在Go中同样重要。有时它们甚至会影响语义：例如，某个名称在包外是否可见，就取决于其首个字符是否为大写字母。因此有必要花点时间来讨论Go程序中的命名约定。

## 包名

当一个包被导入后，包名就会成了内容的访问器。在

```go
import "bytes"
```

之后，被导入的包就能通过 bytes.Buffer 来引用了。这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解。按照惯例，包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法。err的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。不必担心引用次序的冲突。包名就是导入时所需的唯一默认名称，它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下，也可为导入的包选择一个别名来局部使用。无论如何，通过文件名来判定使用的包，都是不会产生混淆的。

另一个约定就是包名应为其源码目录的基本名称。在 src/pkg/encoding/base64中的包应作为 "encoding/base64" 导入，其包名应为 base64，而非encoding_base64或encodingBase64。

包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。（请勿使用import.记法，它可以简化必须在被测试包外运行的测试，除此之外应尽量避免使用。）例如，bufio 包中的缓存读取器类型叫做 Reader而非BufReader，因为用户将它看做 bufio.Reader，这是个清楚而简洁的名称。 此外，由于被导入的项总是通过它们的包名来确定，因此bufio.Reader不会与io.Reader发生冲突。同样，用于创建 ring.Ring 的新实例的函数（这就是Go中的构造函数）一般会称之为NewRing，但由于Ring是该包所导出的唯一类型，且该包也叫ring，因此它可以只叫做New，它跟在包的后面，就像ring.New。使用包结构可以帮助你选择好的名称。

另一个简短的例子是once.Do，once.Do(setup) 表述足够清晰，使用 once.DoOrWaitUntilDone(setup) 完全就是画蛇添足。长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。

## 获取器

Go并不对获取器（getter）和设置器（setter）提供自动支持。你应当自己提供获取器和设置器，通常很值得这样做，但若要将 Get放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为owner（小写，未导出）的字段，其获取器应当名为Owner（大写，可导出）而非GetOwner。大写字母即为可导出的这种规定为区分方法和字段提供了便利。若要提供设置器方法，SetOwner 是个不错的选择。两个命名看起来都很合理：

```go
owner := obj.Owner()
if owner != user {
	obj.SetOwner(user)
}
```

## 接口名

按照约定，只包含一个方法的接口应当以该方法的名称加上-er后缀来命名，如 Reader、Writer、Formatter、CloseNotifier 等。

诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。Read、Write、Close、Flush、String 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。请将字符串转换方法命名为String而非ToString。

## 驼峰记法

最后，Go中约定使用驼峰记法MixedCaps或mixedCaps。