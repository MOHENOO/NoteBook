# 递归

递归是一种强大的方法,它允许一个对象以其自身更小的形式来定义自己.在计算机科学领域中,递归是通过递归函数来实现的.递归函数是一种可以调用自身的函数.每次成功的调用都使得输入变得更加精细,使我们越来越接近问题的答案.

## 基本递归

开始之前,首先来看一个例子,计算整数n的阶乘.一种计算方法时循环遍历其中的每一个树,然后与它之前的数相乘作为结果再参与下一次计算,这种方法称为迭代法.看待这个问题的另一种方式是将其定义为更小的阶乘形式.为了实现这一步.我们将n!定义为n-1阶乘的n倍.如何不断缩小一直到n=1时,我们就计算晚了.这就是递归的形式.

递归过程包含两个基本阶段:递推与回归.在递推阶段,每一个递归调用通过进一步调用自己来记住这次递归过程.当其中有调用满足终止条件时,递推结束.每一个递归函数必须拥有至少一个终止条件;否则,递推阶段就永远不会结束了.一旦递推阶段结束,处理过程就进入回归阶段,在这之前的函数调用以逆序的方式回归,直到最初调用的函数返回为止,此时递归过程结束.

```c
int fact(int n)
{
    if (n < 0)
        return 0;
    else if (n == 0)
    {
        return 1;
    }
    else if (n == 1)
    {
        return 1;
    }
    else
    {
        return n * fact(n - 1);
    }
}
```

为了理解递归究竟是如何工作的,有必要先看看C语言中函数的执行方式.基于这点,我们需要了解一点关于C程序在内存中的组织方式.基本上来说一个可执行程序由4个区域组成:代码段,静态数据区,堆与栈.代码段包含程序运行时所执行的机器指令.静态数据区包含在程序生命周期内一直持久的数据,比如全局变量和静态局部变量.堆包含程序运行时动态分配的存储空间,比如用malloc分配的内存.栈包含函数调用的信息.按照惯例,堆的增长方向为从程序低地址到高地址向上增长,而栈的增长方向刚好相反(实际情况可能不是这样,与CPU的体系结构有关).这里用到的堆和数据结构堆没什么关系.

当C程序调用了一个函数时,栈中会分配一块空间来保存与这个调用相关的信息.每一个调用都被当作是活跃的.栈上的那块存储空间称为活跃记录,或者成为栈帧.栈帧由5个区域组成:输入参数,返回值空间,计算表达式时用到的临时存储空间,函数调用时保存的状态信息以及输出参数.输入参数是传递到活跃记录中的参数;输出参数是传递给在活跃记录中调用的函数所使用的.一个活跃记录中的输出参数就成为栈中下一个活跃记录的输入参数.函数调用产生的活跃记录将一张存在于栈中直到这个函数调用结束.

函数调用示例中的fact(4!)函数会发生什么,初始调用fact会在栈中产生一个活跃记录,输入参数n=4.由于这个调用没有满足函数的终止条件,因此fact将继续以n=3为参数递归调用.这将在栈上创建另一个活跃记录,但这次的输入参数n=3,也是第一个活跃期中的输出参数,因为正是在第一个活跃期内调用fact产生了第二个活跃期.这个过程将一直继续,知道n的值变为1,此时满足终止条件,fact将返回1.

一旦当n=1时的活跃期结束,n=2时的递归运算结果也将计算出来,此时n=2时的活跃期也将结束,最终返回计算结果.

栈是用来存储函数调用信息的绝好方案,这正是其后进先出的特点精确满足了函数调用和返回的顺序.然而,使用栈也有一些缺点.栈维护了每个函数调用的信息直到函数返回后才释放,这需要占用相当大的空间,尤其是在程序中使用了许多递归调用的情况下.除此之外,因为由大量的信息需要保存和恢复,因此生成和销毁活跃记录需要耗费一定的时间.如此一来当函数调用的开销变得很大时,我们就需要考虑采用迭代的方案.幸运的是,我们可以采用一种称为尾递归的特殊递归方式来避免前面提到的这些缺点.

## 尾递归

如果一个函数中所有递归形式的调用都出现在函数的末尾,我们称这个递归函数是尾递归.当递归调用是整个函数体中最后执行的语句且他的返回值不属于表达式的一部分时,这个递归调用就是尾递归.尾递归函数的特点是在回归过程中不用做任何操作,这个特性很重要,因为大多数现代编译器会利用这种特点自动生成优化的代码.

当编译器检测到一个函数调用是尾递归的时候,它就会覆盖当前的活跃记录而不是在栈中创建一个新的.编译器可以做到这点,因为递归调用是当前活跃期内最好一条待执行的语句,于是当这个调用返回时栈帧中并没有其他事情可做,因此也就没有保存栈帧的必要了.通过覆盖当前的栈帧而不是在其之上重新添加一个,这样所使用的栈空间就大大缩减了,这使得实际的运行效率变得更高.因此,只要有可能我们就需要将递归函数写成尾递归的形式.

为了理解尾递归是如何工作的,我们对比之前的fact函数,在每个活跃期计算n倍的(n-1)!的值,在每个活跃期的返回值都依赖于n乘下一个活跃器的返回值,因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定.现在让我们用尾递归的形式来定义计算n!的过程.

```c
int facttail(int n, int a)
{
    if (n < 0)
        return 0;
    else if (n == 0)
    {
        return 1;
    }
    else if (n == 1)
    {
        return a;
    }
    else
    {
        return facttail(n - 1, n * a);
    }
}
```

在facttail中最后一条语句是对facttail的调用,但这并不是必须的.换句话来说,在递归调用之后还可以有其他的语句执行,只是它们只能在递归调用没有执行时才能执行.

**尾递归消除**:在函数中将最终的尾递归调用替换为等同的迭代控制结构,这不好改变函数的输出结果但能够避免一次额外的函数调用开销.在编译器设计中尾递归消除是一个重要的基本法则.