# 预备知识

## 概述

### 数据结构简介

>数据结构是组织信息的一种概念

使用数据结构的三个原因:效率,抽象和重用性

>在C语言里,通过使用指向void类型的指针来管理任意类型的数据,而不是在数据结构内部维护一份数据的私有副本.

### 算法简介

>算法是定义良好的用了解决问题的步骤

使用算法的三个原因:效率,抽象和重用性

### 算法设计的一般方法

- 随机法

随机法依赖于随机数的统计特性.一个应用随机法的例子是快速排序.快速排序中为了获得较高的性能,随机选择一个作为中间值作为划分的依据.这时快排的平均性能很不错,因为随机数的正态分布使得划分结果是相对平衡的.

- 分治法

分治法包含3个步骤:分解,求解与合并.在分解阶段,将数据分解为更小,更容易管理的部分.在求解阶段,对每个分解出的部分进行处理.在合并阶段,将每部分处理的结果进行合并.一个分治法的例子是归并排序.

- 动态规划

动态规划同分治法类似,都是将较大的问题分解为子问题最后再将结果合并.然而,它们处理问题的方式与子问题之间的关系有关.在分治法中每一个子问题都是独立的.为此,我们以递归的方式解决每一个子问题,然后将结果与其他子问题的结果合并.在动态规划中,子问题之间并不是独立的.换句话说,子问题之间可能有关联.这类问题采用动态规划法必分治法来解决更合适.因为若用分治法来解决这类问题会多做很多不必要的工作,有些子问题会重复计算多次.

- 贪心法

贪心法在求解问题时总能够做出当前的最佳选择.换言之,不是从整体最优上考虑,而仅仅是某种意义上的局部最优解.遗憾的是,当前的最优解长远来看却未必是最优的.因此,贪心法并不会一直产生最优结果.然而,在某些方面来说,贪心法确是最佳选择.一个采用贪心法的例子是霍夫曼编码.

- 近似法

近似法并不计算出最优解,相反,它只计算出足够好的解.通常利用近似法解决那些计算成本很高又因为本身十分有价值而不愿放弃的问题.推销员问题是一个通常会用近似法去解决的问题.

### 软件工程

- 模块化

在软件设计中为了达到模块化的目的,一种方法是将精力集中在黑盒上.在软件开发中黑盒代表一个模块,它的内部实现并不希望被使用这个模块的用户看到.用户只能通过模块设计者预定义好的公共接口和这个模块交互.这就是说,设计者仅仅只公开用户需要使用这个模块的必要信息,而将其他所有实现细节都隐藏起来.其结果就是用户并不关心模块的实现细节,也避免了与模块的内部实现相耦合.软件工程中的这一思想在面向对象语言中更是被强制施行.

- 可读性

通过一些方法我们能使程序变得更加可读.编写有意义的注释,使用贴切的标识符,编写自注释的代码.一个好的基本准则是加上注释以便其他的开发人员能够很容易地通过阅读注释来理解程序.另一方面,如果代码是自注释的则不需要添加注释.

- 简介性

- 一致性

在软件开发中,一件非常值得去做的事情是建立编码约定并一直遵守这个约定.

## 指针操作

在C语言中,对于任何类型T,我们都可以在T所在的内存地址处产生一个包含此对象的对应变量.如果用比较直观的方式来看待这种变量,它们实际上是一种指向对象的变量,因此,这些变量称为指针.在C语言中,指针的重要性不言而喻,但在很多时候,又认为指针是一把双刃剑.一方面,指针是构建数据结构和操作内存的精确而高效的工具.另一方面,它们又很容易误用,从而产生不可预知的软件bug.

### 指针基础

一个指针其实只是一个变量,它存储数据在内存中的地址而不是存储数据本身.也就是说,指针包含内存地址.理解指针的最好方法之一就是绘制图表.对于其他类型的任何变量,除非我们显式地指定过,否则我们都不应该假设它指向一个有效的地址.同样需要记住的是,在C语言中,我们无法改变的一个事实就是指针能够指向一个无效的地址.指向无效地址的指针有时被称为悬空指针.可能产生悬空指针的一些编程错误示例包括:将任意的整型变量强制转换为指针变量;操作超出数据边界的指针;释放一个或多个仍被引用的指针.

### 存储空间分配
