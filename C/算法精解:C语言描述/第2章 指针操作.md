# 指针操作

在C语言中,对于任何类型T,我们都可以在T所在的内存地址处产生一个包含此对象的对应变量.如果用比较直观的方式来看待这种变量,它们实际上是一种指向对象的变量,因此,这些变量称为指针.在C语言中,指针的重要性不言而喻,但在很多时候,又认为指针是一把双刃剑.一方面,指针是构建数据结构和操作内存的精确而高效的工具.另一方面,它们又很容易误用,从而产生不可预知的软件bug.

## 指针基础

一个指针其实只是一个变量,它存储数据在内存中的地址而不是存储数据本身.也就是说,指针包含内存地址.理解指针的最好方法之一就是绘制图表.对于其他类型的任何变量,除非我们显式地指定过,否则我们都不应该假设它指向一个有效的地址.同样需要记住的是,在C语言中,我们无法改变的一个事实就是指针能够指向一个无效的地址.指向无效地址的指针有时被称为悬空指针.可能产生悬空指针的一些编程错误示例包括:将任意的整型变量强制转换为指针变量;操作超出数据边界的指针;释放一个或多个仍被引用的指针.

## 存储空间分配

当在C中声明一个指针时与声明其他类型的变量类似,一定量的存储空间会分配给这个指针.通常情况下指针会占用一个机器字长的存储空间,但有时候它们的大小也有所不同.因此,为了保证代码的可移植性,不应该假设每个指针都占有一个特定大小的存储空间.指针变量的大小通常于编译器的设定以及某些特定的C实现中的类型界定符有关.必须要记住的一点是:当声明一个指针时,仅仅只是为指针本身分配了空间,并没有为指针所引用的数据分配空间.而为数据分配存储空间有两种方法:一种时直接声明一个变量;另一种是在运行时动态地分配存储空间(例如malloc或realloc).

当声明一个变量时,编译器会根据变量的类型预留足够的内存空间.变量的存储空间是系统自动分配的,但此存储空间不会在程序的整个生命周期中永久存在,这一点在处理自动变量时尤为重要.自动变量是一种在进入或离开一个模块或函数时其存储空间能够自动分配或释放的变量.例如函数f中,iptr的赋值为变量a的地址,当函数f返回时,iptr变成了一个悬空指针.因为当函数f返回时,变量a已经从函数栈中弹出,变成了一个不合法的变量.

```c
int f(int **iptr){
    int a = 10;
    *iptr = &a;
    return 0;
}
```

在C语言中,当想要动态分配存储空间时,我们会得到一个指向一个堆存储空间的指针.此存储空间由我们自行管理,并且会一直存在,除非我们显示地将它释放.例如:在下面这段代码中用malloc分配的存储空间会一直有效直到调用函数free来释放它.所以,当函数g返回时此存储空间仍然有效,这一点与之前自动分配存储空间的变量完全不同.参数iptr是一个指向我们想要改变其内容的对象的指针(此对象也是一个指针),所以当g返回时,iptr指向由malloc申请的地址空间.

```c
#include <stdui.h>
int g(int **iptr){
    if ((*iptr=(int *)malloc(sizeof(int)))==NULL)
        return -1;
    return 0;
}
```

有些时候,我们甚至会认为指针和动态存储空间分配时C语言领域中不太好的特性.特别是当生产了由动态内存分配所造成的内存泄漏问题时.内存泄露问题的产生是由于动态分配了内存空间,但从未释放它(甚至在程序不再使用此数据空间时都不释放它)造成的.特别是在重复执行代码时,这种泄漏问题会表现的尤为严重.好在我们可以采用统一的内存管理方法来大大减少此类问题.

一种统一的内存管理方法例子就是数据结构实例.每种实例所遵循的理念是,由用户来管理空间以及存储空间相关的实际的数据结构,而数据结构自身只用于维护数据内部变量的存储空间分配.所以,在数据结构中,只使用指针所指向数据变量,而不是此数据的私有副本.这种应用的一个重要意义在于,一个数据结构的实现并不依赖于它所存储的数据的类型和大小.同时,多个数据结构能够以单个数据形态表现,这个特性在组织大量数据时非常有用.

此外,本书还提供了如何初始化和销毁数据结构的操作.初始化可能会涉及很多步骤,其中之一便是内存分配.销毁数据结构通常包括删除它所有的数据,并释放数据结构所用到的内存.释放数据结构的内存往往也包含释放于数据结构相关联的所有内存.这里有一个例外,那就是让用户自己管理数据的存储.之所以每个数据结构在初始化的时候都需要使用由用户提供的初始化函数,是因为数据存储的管理实际上是一种于具体应用相关的操作.

## 数据集合与指针的算数运算

指针在C语言中最常见的用途就是用来引用数据集合.数据集合是有多个相关联的元素构成的数据.C语言支持两种数据集合:结构和数据.(虽然联合与结构类似,但一般它单独被归为一类.)

## 结构

结构通常是由各种各样的有序的元素组成的,从而它可以被看做单个连续的数据类型.结构指针是构建一个数据结构的重要组成部分.结构使我们能把数据捆绑在一起,指针使我们能够让这些捆绑包在内存中一个一个连接起来.用这些连接起来的结构,我们可以对它们加以组织并用来解决实际问题.

这里有一个例子,考虑把内存中一些元素组合起来形成一个链表(见第5章).要做到这一点,我们可能会使用下面代码中所示的像listElmt一样的结构,用每个元素的next来指向下一个元素,并把最后一个元素的next设定为NULL来表示链表的结尾.同时,每个元素的data指向此元素所包含的数据.一旦生成了这样一个列表,就可以用next指针遍历整个链表.

```c
typedef struct ListElmt{
    void *data;
    struct ListElmt *next;
}ListElmt;
```

结构ListElmt也指出了关于结构指针的另一个重要方面:结构不允许包含自身的实例,但可以包含指向自身实例的指针.这种编程思想非常重要,因为很多数据结构都可能是由它自身的结构变量所组成,例如,在一个链表中,每个ListElmt结构都指向另一个ListElmt结构.有些数据结构甚至会包含多个由自身结构类型组成的结构,例如在一个二叉树中(见第9章),每个节点同时指向其他两个二叉树的节点.

## 数组

数据是在内存中连续排列的同类元素的序列.在C语言中,数据与指针密不可分.事实上,当一个数组标识符在表达式中出现时,C语言显然会把数据转换为一个指向数组第一个元素的固定指针.考虑到这一点,以下两个函数是等价的.

数组引用

```c
int f(){
    int a[10],*iptr;
    iptr =a;
    iptr[0]=5;
    return 0;
}
```

指针引用

```c
int g(){
    int a[10],*iptr;
    iptr=a;
    *iptr=5;
    return 0;
}
```

为了理解C语言中指针于数组的关系,我们知道要访问一个数组的第i个元素a[i],在C语言中,这个表达式与指向a的第一元素的指针表达意思相同,也就是说改表达式等同于*(a+i).此表达时实际上是使用指针运算的规则来访问元素的.简单来说,当对指针进行加一个整数i操作时,实际得到了一个地址,这个地址由a所在的地址加上数据类型a所含字节数乘i得到;而并不是简单地在a所在的地址上加i个字节.当从指针中减去一个整数时也是执行类似操作.这样我们也就解释了为什么数组的索引是从0开始的,因为数据的第一个元素在位置0.

把一个多维数组转换为指针与把一维数组转换为指针的过程类似.但是同时要知道在C语言中,多维数组其实是以行主序存储的,这也就是说明多位数组右边下标变化速度要比左边下标变化的更快.要访问一个二维数组第i行第j列的元素,用a[i][j].C语言在表达式中将a当作指向改数组第1行第1列中元素的指针.整个表达式等价于:\*(\*(a+i)+j).对指针进行加法（减法）运算时,它前进（后退）的步长与它指向的数据类型有关,a指向的数据类型是数组,所以a+i表示指针指向数组的i行.*(a+i)单独使用时表示的是第 i 行数据,放在表达式中会被转换为第i行数据的首地址,也就是第i行第0个元素的地址,因为使用整行数据没有实际的含义,编译器遇到这种情况都会转换为指向该行第0个元素的指针；就像一维数组的名字,在定义时或者和sizeof、&一起使用时才表示整个数组,出现在表达式中就会被转换为指向数组第0个元素的指针。

## 作为函数参数的指针

在C语言的函数调用中指针起着至关重要的作用.最重要的是,指针支持将参数作为引用传递给函数(即按引用调用).按引用传递参数是,当函数改变此参数时,这个被改变参数的值会一直存在,甚至函数退出后都仍然存在.相对而言,当按值调用传递函数时,此时值z的改变只能持续到函数返回时.无论是否要改变函数的输入输出参数,使用指针传递大容量复杂的函数参数也是十分高效的手段.这样可以大大地节省内存空间.

## 按引用调用传递参数

在形式上,C语言只支持按值来传递参数.在按值调用传递参数的过程中,函数参数的一份私有副本将会用到函数的执行体中.然而,我们可以模仿按引用传递参数将一个指向参数的指针(而不是参数本身)传递给函数,这样函数调用者可以得到一个指针的私有副本用于函数体的执行过程.

要了解按引用调用是如何实现的,我们来看看swap1.swap1是一个实现将两个整型变量相互交换的函数,函数参数是通过按值调用传递的.所以得到的结果是错误的.swap2同样是一个交换函数,只是它的参数是按引用调用传递的.

```c
void swap1(int x,int y){
    int tmp;
    tmp=x;
    x=y;
    y=tmp;
    return;
}

void swap2(int *x,int *y){
    int tmp;
    tmp=*x;
    *x=*y;
    *y=tmp;
    return;
}
```

c语言中按引用调用传递参数,其好的一面是语言本身赋予了我们精确控制参数传递的能力.不好的方面是,这种控制有时候会显得很麻烦,因为我们常常需要在函数中多次解引用按引用调用的参数.

另一个在函数调用时会用到指针的地方,就是把数组传递给函数的时候.C语言把数组名当作一个不可变的指针来使用,当向函数传递一个类型为T的数组对象时,其实就等同于向函数传递一个指向类型为T的对象的指针.所以下面的f1和f2等价.

```c
int f1(int a[]){
    a[0]=5;
    return 0;
}

int f2(int *a){
    *a=5;
    return 0;
}
```

具体使用哪种方式来传递参数取决于约定俗成或函数处理参数的方法,当使用一个数组作为参数时,数组的边界信息并不重要,因为此时编译器并不要求数组有边界信息.但是,提供边界信息对于表达出函数内部处理该参数具有一定的局限性是一种很有用的方法.在使用多维数组作为参数的函数中,边界信息显得尤为重要.

当把一个多维数组传递给函数时,除了第一维以外,其他维的长度必须指定,这样函数才能通过指针算术运算访问具体元素,如下所示

```c
int g(int a[][2]){
    a[2][0]=5;
    return 0;
}
```

为了更清楚地理解为什么必须指定第二维度的大小,设定有一个3行2列的整型二维数组.在C语言中,此二维数组的元素在内存中按照地址的递增一行一行顺序排列.所以,如果想访问到任意一行的元素(除了第一行时),我们必须确切知道达到这一行我们需要跳过多少个连续的元素.

## 作为参数指向指针的指针

函数想改变传递给它的指针,需要向函数传递一个待改变的指向指针的指针.这是一种用来删除数据结构中数据的典型方法.

## 泛型指针与类型转换

在C中指针变量拥有与其他变量一样的类型.之所以指针变量会有类型是因为当我们想获取指针变量的值时,编译器已经指针指针所指向的数据的类型,从而可以访问相应的数据.但是有时候我们并不关心指针所指向的变量的类型.在这种情况下可以使用泛型指针.泛型指针并不确定具体的数据类型.

### 泛型指针

通常情况下,C只允许相同类型的指针之间进行转换.但是泛型指针能够转换为任何类型的指针,反之亦然.在C语言中,通常声明一个void指针来表示泛型指针.

很多情况下void指针都是非常有用的.例如:C标准函数库中的memcpu函数,它将一段数据从内存中的一个地方复制到另一个地方.void指针同样也可以用到其他普通的函数中.例如:之前使用的交换函数swap2.

```c
#include <stdio.h>
#include <string.h>
int swapw(void *x,void *y,int size)
{
    void *tmp;
    if ((tmp=malloc(size))==NULL)
        return -1;
    memcpy(tmp,x,size);
    memcpy(x,y,size);
    memcpy(y,tmp,size);

    free(tmp);

    return 0;
}
```

void指针在用来实现数据结构时是非常有用的,因为可以通过void指针存储和检索任何类型的数据.

虽然void指针与其他类型的指针相兼容,但是一个指向void指针的指针并不一定与其他类型的指针兼容.

### 类型转换

要将类型为T的变量t转换成S类型,只需要在t前加上用圆括号括上的S.指针指向的值的类型由我们用什么类型的指针访问它决定.

对于泛型指针来说类型转换非常重要,因为只有告诉泛型指针是通过何种类型来访问地址时,泛型指针才能正确取到值.这是由于泛型指针不会告诉编译器它指向的是何种类型数据,因此编译器既不知道多少个字节要被访问,也不知道应该如何解析字节.当将泛型指针赋值给其他类型的指针时,使用类型转换也是一种很好的代码自注释方法.尽管这里的转换并不是必需的,但这样能大大提高程序的可读性.

当转换指针时,我们对内存中的数据对齐方式必须特别注意.具体来说,我们需要知道,指针的类型转换会破坏计算机本身的对齐方式.很多计算机对对齐的方式有要求,以便某些硬件的优化可以使访问内存更有效率.例如,一个系统可能要求所有整数按字边界对其.所以,如果有一个非按字对其的void指针,当将它转换为一个整型指针并试图获取它的值时,程序可能在运行时出现异常.

## 函数指针

函数指针是指向可执行代码段或调用可执行代码段的信息块的指针,而不是指向某种数据的指针.函数指针将函数当作普通数据那样存储和管理.函数指针有一种固定的形式,就是包含一个确定的返回值类型和若干个函数参数.声明一个函数指针看起来和什么一个函数非常类似,只是在函数名之前有一个表示指针的星号(*),并且函数名和星号会用圆括号括起来.

```c
int (*match)(void *key1,void *key2);
```

假设又一个match_int函数,可以这样赋值:

```c
match=match_int
```

要执行一个由函数指针所引用的函数,只需要在正常调用普通函数的地方调用函数指针.例如:

```c
retval=match(&x,&y);
```

函数指针的一个重要用途是将函数封装到数据结构中.使用指针吧函数另存为数据结构的一部分是C语言一种非常好的特性,因为它可以使数据结构或函数变得更具通用性.