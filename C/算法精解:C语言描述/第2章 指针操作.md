# 指针操作

在C语言中,对于任何类型T,我们都可以在T所在的内存地址处产生一个包含此对象的对应变量.如果用比较直观的方式来看待这种变量,它们实际上是一种指向对象的变量,因此,这些变量称为指针.在C语言中,指针的重要性不言而喻,但在很多时候,又认为指针是一把双刃剑.一方面,指针是构建数据结构和操作内存的精确而高效的工具.另一方面,它们又很容易误用,从而产生不可预知的软件bug.

## 指针基础

一个指针其实只是一个变量,它存储数据在内存中的地址而不是存储数据本身.也就是说,指针包含内存地址.理解指针的最好方法之一就是绘制图表.对于其他类型的任何变量,除非我们显式地指定过,否则我们都不应该假设它指向一个有效的地址.同样需要记住的是,在C语言中,我们无法改变的一个事实就是指针能够指向一个无效的地址.指向无效地址的指针有时被称为悬空指针.可能产生悬空指针的一些编程错误示例包括:将任意的整型变量强制转换为指针变量;操作超出数据边界的指针;释放一个或多个仍被引用的指针.

## 存储空间分配

当在C中声明一个指针时与声明其他类型的变量类似,一定量的存储空间会分配给这个指针.通常情况下指针会占用一个机器字长的存储空间,但有时候它们的大小也有所不同.因此,为了保证代码的可移植性,不应该假设每个指针都占有一个特定大小的存储空间.指针变量的大小通常于编译器的设定以及某些特定的C实现中的类型界定符有关.必须要记住的一点是:当声明一个指针时,仅仅只是为指针本身分配了空间,并没有为指针所引用的数据分配空间.而为数据分配存储空间有两种方法:一种时直接声明一个变量;另一种是在运行时动态地分配存储空间(例如malloc或realloc).

当声明一个变量时,编译器会根据变量的类型预留足够的内存空间.变量的存储空间是系统自动分配的,但此存储空间不会在程序的整个生命周期中永久存在,这一点在处理自动变量时尤为重要.自动变量是一种在进入或离开一个模块或函数时其存储空间能够自动分配或释放的变量.例如函数f中,iptr的赋值为变量a的地址,当函数f返回时,iptr变成了一个悬空指针.因为当函数f返回时,变量a已经从函数栈中弹出,变成了一个不合法的变量.

```c
int f(int **iptr){
    int a = 10;
    *iptr = &a;
    return 0;
}
```

在C语言中,当想要动态分配存储空间时,我们会得到一个指向一个堆存储空间的指针.此存储空间由我们自行管理,并且会一直存在,除非我们显示地将它释放.例如:在下面这段代码中用malloc分配的存储空间会一直有效直到调用函数free来释放它.所以,当函数g返回时此存储空间仍然有效,这一点与之前自动分配存储空间的变量完全不同.参数iptr是一个指向我们想要改变其内容的对象的指针(此对象也是一个指针),所以当g返回时,iptr指向由malloc申请的地址空间.

```c
#include <stdui.h>
int g(int **iptr){
    if ((*iptr=(int *)malloc(sizeof(int)))==NULL)
        return -1;
    return 0;
}
```

有些时候,我们甚至会认为指针和动态存储空间分配时C语言领域中不太好的特性.特别是当生产了由动态内存分配所造成的内存泄漏问题时.内存泄露问题的产生是由于动态分配了内存空间,但从未释放它(甚至在程序不再使用此数据空间时都不释放它)造成的.特别是在重复执行代码时,这种泄漏问题会表现的尤为严重.好在我们可以采用统一的内存管理方法来大大减少此类问题.

一种统一的内存管理方法例子就是数据结构实例.每种实例所遵循的理念是,由用户来管理空间以及存储空间相关的实际的数据结构,而数据结构自身只用于维护数据内部变量的存储空间分配.所以,在数据结构中,只使用指针所指向数据变量,而不是此数据的私有副本.这种应用的一个重要意义在于,一个数据结构的实现并不依赖于它所存储的数据的类型和大小.同时,多个数据结构能够以单个数据形态表现,这个特性在组织大量数据时非常有用.

此外,本书还提供了如何初始化和销毁数据结构的操作.初始化可能会涉及很多步骤,其中之一便是内存分配.销毁数据结构通常包括删除它所有的数据,并释放数据结构所用到的内存.释放数据结构的内存往往也包含释放于数据结构相关联的所有内存.这里有一个例外,那就是让用户自己管理数据的存储.之所以每个数据结构在初始化的时候都需要使用由用户提供的初始化函数,是因为数据存储的管理实际上是一种于具体应用相关的操作.

## 数据集合与指针的算数运算

指针在C语言中最常见的用途就是用来引用数据集合.数据集合是有多个相关联的元素构成的数据.C语言支持两种数据集合:结构和数据.(虽然联合于结构类似,但一般它单独被归为一类.)

## 结构

结构通常是由各种各样的有序的元素组成的,从而它可以被看做单个连续的数据类型.结构指针是构建一个数据结构的重要组成部分.结构使我们能把数据捆绑在一起,指针使我们能够让这些捆绑包在内存中一个一个连接起来.用这些连接起来的结构,我们可以对它们加以组织并用来解决实际问题.

这里有一个例子,考虑把内存中一些元素组合起来形成一个链表(见第5章).要做到这一点,我们可能会使用下面代码中所示的像listElmt一样的结构,用每个元素的next来指向下一个元素,并把最后一个元素的next设定为NULL来表示链表的结尾.同时,每个元素的data指向此元素所包含的数据.一旦生成了这样一个列表,就可以用next指针遍历整个链表.

```c
typedef struct ListElmt{
    void *data;
    struct ListElmt *next;
}ListElmt;
```

结构ListElmt也指出了关于结构指针的另一个重要方面:结构不允许包含自身的实例,但可以包含指向自身实例的指针.这种编程思想非常重要,因为很多数据结构都可能是由它自身的结构变量所组成,例如,在一个链表中,每个ListElmt结构都指向另一个ListElmt结构.有些数据结构甚至会包含多个由自身结构类型组成的结构,例如在一个二叉树中(见第9章),每个节点同时指向其他两个二叉树的节点.

## 数组

数据是在内存中连续排列的同类元素的序列.在C语言中,数据与指针密不可分.事实上,当一个数组标识符在表达式中出现时,C语言显然会把数据转换为一个指向数组第一个元素的固定指针.考虑到这一点,以下两个函数是等价的.

数组引用

```c
int f(){
    int a[10],*iptr;
    iptr =a;
    iptr[0]=5;
    return 0;
}
```

指针引用

```c
int g(){
    int a[10],*iptr;
    iptr=a;
    *iptr=5;
    return 0;
}
```

为了理解C语言中指针于数组的关系,我们知道要访问一个数组的第i个元素a[i],在C语言中,这个表达式与指向a的第一元素的指针表达意思相同,也就是说改表达式等同于*(a+i).此表达时实际上是使用指针运算的规则来访问元素的.简单来说,当对指针进行加一个整数i操作时,实际得到了一个地址,这个地址由a所在的地址加上数据类型a所含字节数乘i得到;而并不是简单地在a所在的地址上加i个字节.当从指针中减去一个整数时也是执行类似操作.这样我们也就解释了为什么数组的索引是从0开始的,因为数据的第一个元素在位置0.

把一个多维数组转换为指针与把一维数组转换为指针的过程类似.但是同时要知道在C语言中,多维数组其实是以行主序存储的,这也就是说明多位数组右边下标变化速度要比左边下标变化的更快.要访问一个二维数组第i行第j列的元素,用a[i][j].C语言在表达式中将a当作指向改数组第1行第1列中元素的指针.整个表达式等价于:\*(\*(a+i)+j)

## 作为函数参数的指针
