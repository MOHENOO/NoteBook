# 使用视图

## 视图

视图是虚拟的表.与包含数据的表不一样,视图只包含使用时动态检索数据的查询.

**DBMS支持**:Access不支持视图,没有与SQL视图一致的工作方式.MySQL从版本5起开始支持视图.SQLite仅支持只读视图,所以视图可以创建,可以读,但其内容不可更改.

### 为什么使用视图

- 重用SQL语句
- 简化复杂的SQL操作.在编写查询后,可以方便地重用它而不必知道其基本查询细节.
- 使用表的一部分而不是整个表.
- 保护数据.可以授予用户访问表的特定部分权限,而不是整个表的访问权限.
- 更改数据格式和表示.视图可返回与底层表的表示和格式不同的数据.

创建视图之后,可以用与表基本相同的方式使用它们.可以对视图执行SELECT操作,过滤和排序数据,将视图联结到其他视图或表,甚至添加和更新数据(添加和更新数据存在某些限制).

视图仅仅是用来查看存储在别处数据的一种设施.视图本身不包含数据,因此返回的数据是从其他表中检索出来的.在添加或更改这些表中的数据时,视图将返回改变过的数据.

**性能问题**:因为视图不包含数据,所以每次使用视图时,都必须处理查询执行时需要的所有检索.如果你用多个表联结和过滤创建了复杂的视图或者嵌套了视图,性能可能会下降得很厉害.因此,在部署使用了大量视图的应用前,应该进行测试.

### 视图的规则和限制

创建视图前,应该知道它的一些限制.不过这些限制随不同的DBMS而不同,因此在创建视图时应该查看具体的DBMS文档.

- 与表一样,视图必须唯一命名(不能给视图取与别的视图或表相同的名字).
- 对于可以创建的视图数目没有限制.
- 创建视图,必须具有足够的访问权限.这些权限通常由数据库管理人员授予.
- 视图可以嵌套,即可以利用从其他视图中检索数据的查询来构造视图.所允许的嵌套层数在不同的DBMS中有所不同(嵌套视图可能会严重降低查询的性能,因此在产品环境使用之前,应该对其进行全面测试).
- 许多DBMS禁止在视图中使用ORDER BY子句.
- 有些DBMS要求对返回的所有列进行命名,如果列是计算字段,则需要使用别名.
- 视图不能索引,也不能有关联的触发器或默认值.
- 有些DBMS把视图作为只读的查询,这表示可以从视图检索数据,但不能将数据写回底层表.
- 有些DBMS允许创建这样的视图,它不能进行导致行不再属于视图的插入或更新.例如一个视图,只检索带有电子邮件地址的顾客.如果更新某个顾客,删除他的电子邮件地址,将使该顾客不再属于视图.这是默认行为,而且是允许的,但有的DBMS可能会防止这种情况发生.

## 创建视图

视图用CREATE VIEW语句来创建.与CREATE TABLE一样,CREATE VIEW只能用于创建不存在的视图.

删除视图可以使用DROP VIEW viewname;

覆盖或更新视图,必须先删除它,然后再重新创建.

### 利用视图简化复杂的联结

```sql
CREATE VIEW ProductCustomers AS
SELECT cust_name,cust_contact,prod_id
FROM Customers,Orders,OrderItems
WHERE Customers.cust_id=Orders.cust_id
AND OrderItems.order_num=Orders.order_num;
```

视图极大地简化了复杂SQL语句的使用.利用视图,可以一次性编写基础的SQL,然后根据需要多次使用.

### 用视图重新格式化检索出的数据

视图的另一常见用途是重新格式化检索出的数据

```sql
CREATE VIEW VendorLocations AS
SELECT RTRIM(vend_name)+' ('+RTRIM(vend_country)+')'
AS vend_title
FROM Vendors
ORDER BY vend_name;
```

### 用视图过滤不想要的数据

视图对于应用普通的WHERE子句也很有用.

**WHERE子句于WHERE子句**:从视图检索数据时如果使用了一条WHERE子句,则两组子句(一组在视图中,另一组是传递给视图的)将自动组合.

### 使用视图与计算字段

### 为什么很少使用视图

实际使用中,使用视图可能使问题复杂化,不便于控制.